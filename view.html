<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <title>Laudo Interativo</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; margin: 0; display: flex; height: 100vh; background-color: #2c3e50; color: #ecf0f1; }
        #image-container { flex: 3; display: flex; justify-content: center; align-items: center; padding: 1rem; overflow: hidden; background-color: #232323; }
        #canvas-report { max-width: 100%; max-height: 100%; object-fit: contain; }
        #findings-container { flex: 1.2; padding: 1rem; background-color: #34495e; overflow-y: auto; font-size: 14px; border-left: 2px solid #2c3e50; }
        #findings-container h1 { color: #3498db; border-bottom: 1px solid #3498db; padding-bottom: 10px; margin-top: 0; }
        #findings-container p { cursor: pointer; padding: 8px; border-radius: 4px; margin: 5px 0; transition: all 0.2s ease-in-out; border: 1px solid transparent; }
        
        /* Estilo do novo botão */
        #toggle-all-btn {
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 5px;
            padding: 10px 15px;
            margin: 0 0 15px 0;
            cursor: pointer;
            width: 100%;
            font-size: 14px;
            font-weight: bold;
            transition: background-color 0.2s;
        }
        #toggle-all-btn:hover { background-color: #2980b9; }
        #toggle-all-btn.active { background-color: #e74c3c; }

    </style>
</head>
<body>
    <div id="image-container"><canvas id="canvas-report"></canvas></div>
    <div id="findings-container">
        <!-- O conteúdo dos achados será inserido pelo script principal -->
    </div>

    <script>
        const DATA = ${JSON.stringify(data)};
        const canvas = document.getElementById('canvas-report');
        const ctx = canvas.getContext('2d');
        const findingsContainer = document.getElementById('findings-container');
        
        // --- NOVAS VARIÁVEIS DE ESTADO ---
        let hoverId = null, pinnedId = null;
        let hoverColor = null, pinnedColor = null;
        let hoverText = null, pinnedText = null;
        let showAllMode = false; // Controla o modo "Visualizar Todos"

        // Insere o HTML dos achados e o novo botão
        findingsContainer.innerHTML = `
            <h1>Achados Radiográficos</h1>
            <button id="toggle-all-btn">Visualizar todos os achados na Imagem</button>
            ${DATA.findingsHtml}
        `;
        const toggleAllBtn = document.getElementById('toggle-all-btn');

        const image = new Image();
        image.onload = () => {
            canvas.width = image.naturalWidth;
            canvas.height = image.naturalHeight;
            redrawAll();
            findingsContainer.querySelectorAll('p[data-annotation-id]').forEach(p => p.classList.add('finding-item'));
        };
        image.src = DATA.image;

        function findAnnotationById(id) { return id ? DATA.annotations.find(a => a.id === id) : null; }
        function convertImgToCanvas(p) { return { x: p.x * canvas.width, y: p.y * canvas.height }; }
        
        function redrawAll() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(image, 0, 0);

            if (showAllMode) {
                // MODO "VISUALIZAR TODOS": Desenha todas as anotações
                DATA.annotations.forEach(anno => {
                    const isHovered = anno.id === hoverId;
                    // Encontra o elemento de texto correspondente para pegar a cor
                    const findingEl = findingsContainer.querySelector(`[data-annotation-id="${anno.id}"]`);
                    const color = findingEl ? findingEl.dataset.highlightColor : '#FFFFFF';
                    drawAnnotation(anno, color, isHovered); // Passa um flag para destacar no hover
                });
            } else {
                // MODO NORMAL (INDIVIDUAL): Desenha apenas a anotação ativa (fixada ou hover)
                const annotation = findAnnotationById(pinnedId || hoverId);
                const color = pinnedColor || hoverColor;
                const text = pinnedText || hoverText;

                if (annotation) {
                    drawAnnotation(annotation, color, true); // Sempre destaca
                    if (text) {
                        drawAnnotationText(text, annotation);
                    }
                }
            }
        }
        
        // Listener do novo botão
        toggleAllBtn.addEventListener('click', () => {
            showAllMode = !showAllMode; // Inverte o modo
            toggleAllBtn.classList.toggle('active', showAllMode);
            if (showAllMode) {
                toggleAllBtn.textContent = 'Ocultar todos os achados';
                // Limpa a seleção individual para não causar confusão
                pinnedId = null; pinnedColor = null; pinnedText = null;
                findingsContainer.querySelectorAll('.finding-item').forEach(el => el.style.backgroundColor = '');
            } else {
                toggleAllBtn.textContent = 'Visualizar todos os achados na Imagem';
            }
            redrawAll();
        });

        findingsContainer.addEventListener('mouseover', e => {
            const target = e.target.closest('.finding-item');
            if (target) {
                hoverId = target.dataset.annotationId;
                if (!showAllMode) { // Só atualiza a cor e o texto se não estiver no modo "ver todos"
                    hoverColor = target.dataset.highlightColor;
                    hoverText = target.innerHTML;
                }
                redrawAll();
            }
        });

        findingsContainer.addEventListener('mouseout', () => {
            hoverId = null; 
            if (!showAllMode) {
                hoverColor = null;
                hoverText = null;
            }
            redrawAll();
        });

        findingsContainer.addEventListener('click', e => {
            const target = e.target.closest('.finding-item');
            if (target) {
                // Clicar em um item sempre desativa o modo "ver todos" para focar no individual
                if (showAllMode) {
                    showAllMode = false;
                    toggleAllBtn.classList.remove('active');
                    toggleAllBtn.textContent = 'Visualizar todos os achados na Imagem';
                }

                // Lógica de fixar/desfixar
                const clickedId = target.dataset.annotationId;
                const clickedColor = target.dataset.highlightColor;
                const clickedText = target.innerHTML;

                findingsContainer.querySelectorAll('.finding-item').forEach(el => el.style.backgroundColor = '');

                if (pinnedId === clickedId) {
                    pinnedId = null; pinnedColor = null; pinnedText = null;
                } else {
                    pinnedId = clickedId;
                    pinnedColor = clickedColor;
                    pinnedText = clickedText;
                    target.style.backgroundColor = pinnedColor;
                }
                redrawAll();
            }
        });
        
        function getAnnotationAnchorPoint(anno) { /* ...código da função... */ }
        function drawAnnotationText(htmlText, anno) { /* ...código da função... */ }
        
        function drawAnnotation(anno, color, isHighlighted = false) {
            const highlightColor = color || '#00FFFF';
            ctx.save();
            ctx.strokeStyle = highlightColor;
            ctx.fillStyle = highlightColor.startsWith('rgba') ? highlightColor : highlightColor + 'B3';
            ctx.lineWidth = (anno.thickness || 2) + 2;
            ctx.shadowColor = highlightColor;
            ctx.shadowBlur = 20;
            
            if (anno.points && anno.fillColor) { // Polígono
                ctx.beginPath();
                const startPoint = convertImgToCanvas(anno.points[0]);
                ctx.moveTo(startPoint.x, startPoint.y);
                for (let i = 1; i < anno.points.length; i++) { ctx.lineTo(convertImgToCanvas(anno.points[i]).x, convertImgToCanvas(anno.points[i]).y); }
                ctx.closePath();
                ctx.stroke();
                ctx.fill();
            } else if (anno.points) { // Traço livre
                ctx.beginPath();
                const startPoint = convertImgToCanvas(anno.points[0]);
                ctx.moveTo(startPoint.x, startPoint.y);
                for (let i = 1; i < anno.points.length; i++) { ctx.lineTo(convertImgToCanvas(anno.points[i]).x, convertImgToCanvas(anno.points[i]).y); }
                ctx.stroke();
            } else if (anno.start && anno.end) { // Medida
                const p1 = convertImgToCanvas(anno.start); const p2 = convertImgToCanvas(anno.end);
                ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.stroke();
                ctx.font = '16px Arial'; ctx.textAlign = 'center'; ctx.fillStyle = highlightColor;
                ctx.fillText(anno.text, (p1.x + p2.x) / 2, (p1.y + p2.y) / 2 - 8);
            } else if (anno.type && anno.size) { // Seta
                const center = convertImgToCanvas({x: anno.x, y: anno.y});
                const size = anno.size * canvas.width;
                ctx.translate(center.x, center.y);
                ctx.rotate(anno.rotation);
                ctx.scale(anno.scale, anno.scale);
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(-size / 2, 0);
                ctx.lineTo(size / 2, 0);
                ctx.lineTo(size / 2 - 10, -5);
                ctx.moveTo(size / 2, 0);
                ctx.lineTo(size / 2 - 10, 5);
                ctx.stroke();
            } else if (anno.text && anno.font) { // Texto
                 const coords = convertImgToCanvas({ x: anno.x, y: anno.y });
                ctx.font = anno.font; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillStyle = highlightColor;
                ctx.fillText(anno.text, coords.x, coords.y);
            }
            
            ctx.restore();
        }
    </script>
</body>
</html>

