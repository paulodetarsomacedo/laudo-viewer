<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Laudo Interativo</title>
    <style>
        :root { --bg-color: #121212; --panel-bg: #1e1e1e; --text-color: #e0e0e0; --accent: #3498db; --highlight: #f1c40f; }
        body { margin: 0; padding: 0; font-family: 'Segoe UI', Roboto, sans-serif; background-color: var(--bg-color); color: var(--text-color); height: 100vh; overflow: hidden; display: flex; flex-direction: row; }
        
        /* Viewer Area ocupa o espa√ßo restante */
        #viewer-area { flex: 1; position: relative; overflow: hidden; background-color: #000; touch-action: none; display: flex; align-items: center; justify-content: center; }
        
        /* O Canvas ocupa 100% da √°rea dispon√≠vel */
        canvas { display: block; width: 100%; height: 100%; }
        
        /* Sidebar */
        #sidebar { width: 350px; background-color: var(--panel-bg); border-left: 1px solid #333; display: flex; flex-direction: column; z-index: 100; box-shadow: -2px 0 10px rgba(0,0,0,0.5); }
        #header { padding: 15px; background: #252525; border-bottom: 1px solid #333; text-align: center; }
        #header h2 { margin: 0; color: var(--accent); font-size: 18px; }
        
        #findings-list { flex: 1; overflow-y: auto; padding: 15px; }
        
        /* Item da Lista */
        .finding-item { background: #2a2a2a; margin-bottom: 10px; padding: 12px; border-radius: 6px; cursor: pointer; transition: 0.2s; border-left: 4px solid transparent; font-size: 14px; line-height: 1.4; }
        .finding-item:hover { background: #333; transform: translateX(5px); }
        .finding-item.active { background: #383838; border-color: var(--highlight); box-shadow: 0 0 15px rgba(255, 255, 255, 0.05); }
        
        #controls { padding: 15px; border-top: 1px solid #333; display: flex; gap: 10px; flex-direction: column; }
        .btn { background: var(--accent); color: white; border: none; padding: 12px; border-radius: 6px; font-weight: bold; cursor: pointer; font-size: 14px; width: 100%; transition: 0.2s; }
        .btn:hover { filter: brightness(1.1); }
        .btn.secondary { background: #444; }

        @media (max-width: 768px) {
            body { flex-direction: column; }
            #sidebar { width: 100%; height: 40%; border-left: none; border-top: 2px solid var(--accent); }
            #viewer-area { height: 60%; }
        }
    </style>
</head>
<body>

    <div id="viewer-area">
        <canvas id="canvas-report"></canvas>
    </div>

    <div id="sidebar">
        <div id="header">
            <h2>Achados Radiogr√°ficos</h2>
        </div>
        <div id="findings-list">
            ${data.findingsHtml} 
        </div>
        <div id="controls">
            <button id="btn-toggle-all" class="btn">üëÅÔ∏è Ver Todos na Imagem</button>
            <button id="btn-reset-zoom" class="btn secondary">‚ü≤ Resetar Visualiza√ß√£o</button>
        </div>
    </div>

<script>
    const DATA = ${jsonData};
    const viewer = document.getElementById('viewer-area');
    const canvas = document.getElementById('canvas-report');
    const ctx = canvas.getContext('2d');
    const findingsList = document.getElementById('findings-list');
    
    // Vari√°veis de Estado
    let img = new Image();
    let scale = 1, panX = 0, panY = 0;
    let isDragging = false, startX, startY;
    
    // Controle de Anota√ß√µes
    let showAll = false;
    let activeAnnotationId = null;
    let hoveredAnnotationId = null;
    
    // Fator para ajustar tamanho de texto/linhas
    let drawingScaleFactor = 1;

    img.onload = () => {
        // Inicializa o canvas com o tamanho da tela
        resizeCanvas();
        
        // Calcula fator de escala para desenho (linhas n√£o ficarem finas demais)
        // Usa 1500px como base de refer√™ncia m√©dia
        drawingScaleFactor = Math.max(img.naturalWidth / 1500, 1);

        fitImageToScreen(); 
        setupEvents();
        
        // Garante classes nos itens da lista
        document.querySelectorAll('#findings-list p').forEach(p => {
            p.classList.add('finding-item');
        });
    };
    img.src = DATA.image;

    // Atualiza tamanho do canvas se redimensionar a janela
    window.addEventListener('resize', () => {
        resizeCanvas();
        fitImageToScreen();
    });

    function resizeCanvas() {
        canvas.width = viewer.offsetWidth;
        canvas.height = viewer.offsetHeight;
        render();
    }

    // --- RENDERIZA√á√ÉO CENTRALIZADA ---
    function render() {
        // Limpa a tela inteira
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Aplica a transforma√ß√£o (Zoom e Pan)
        ctx.setTransform(scale, 0, 0, scale, panX, panY);
        
        // Desenha a imagem
        ctx.drawImage(img, 0, 0);

        // Desenha anota√ß√µes
        if (showAll) {
            DATA.annotations.forEach(anno => drawAnnotation(anno, false));
        } else {
            const targetId = hoveredAnnotationId || activeAnnotationId;
            if (targetId) {
                const anno = DATA.annotations.find(a => a.id === targetId);
                if (anno) drawAnnotation(anno, true);
            }
        }
    }

    // --- L√ìGICA DE ENCAIXE (A CORRE√á√ÉO PRINCIPAL) ---
    function fitImageToScreen() {
        // Calcula a escala necess√°ria para a imagem caber no canvas atual
        const scaleX = canvas.width / img.naturalWidth;
        const scaleY = canvas.height / img.naturalHeight;
        scale = Math.min(scaleX, scaleY); // "Contain" (caber inteira)
        
        // Centraliza matematicamente
        // (Largura da Tela - (Largura da Imagem * Escala)) / 2 = Espa√ßo vazio de um lado
        panX = (canvas.width - (img.naturalWidth * scale)) / 2;
        panY = (canvas.height - (img.naturalHeight * scale)) / 2;
        
        render();
    }

    function centerOnAnnotation(anno) {
        let targetX, targetY;
        // Pega o ponto central da anota√ß√£o (coordenadas relativas 0-1)
        if(anno.points) { targetX = anno.points[0].x; targetY = anno.points[0].y; }
        else if(anno.start) { targetX = anno.start.x; targetY = anno.start.y; }
        else { targetX = anno.x; targetY = anno.y; }
        
        // Converte para pixels reais da imagem
        const imgX = targetX * img.naturalWidth;
        const imgY = targetY * img.naturalHeight;
        
        // Define um zoom forte para ver o detalhe
        // Se a imagem for muito grande, limita o zoom m√°ximo
        const targetZoom = Math.min(scale * 4, 3); // Zoom de 4x o atual ou max 3.0
        
        // Centraliza esse ponto na tela
        // Nova Posi√ß√£o = (Metade da Tela) - (Ponto na Imagem * Novo Zoom)
        panX = (canvas.width / 2) - (imgX * targetZoom);
        panY = (canvas.height / 2) - (imgY * targetZoom);
        scale = targetZoom;
        
        render();
    }

    function drawAnnotation(anno, isActive) {
        const findingEl = document.querySelector(\`p[data-annotation-id="\${anno.id}"]\`);
        const color = findingEl ? findingEl.dataset.highlightColor : '#00FFFF';

        ctx.save();
        ctx.strokeStyle = color;
        ctx.fillStyle = color;
        
        // Linhas mais grossas para ficarem vis√≠veis na alta resolu√ß√£o
        const baseWidth = (anno.thickness || 3) * drawingScaleFactor;
        ctx.lineWidth = isActive ? baseWidth * 1.5 : baseWidth;
        
        ctx.lineJoin = 'round'; ctx.lineCap = 'round';
        ctx.shadowColor = 'black';
        ctx.shadowBlur = 5 * drawingScaleFactor;

        if (anno.points && anno.fillColor) { // Pol√≠gono
            ctx.beginPath();
            const start = convertCoord(anno.points[0]);
            ctx.moveTo(start.x, start.y);
            for(let i=1; i<anno.points.length; i++) {
                const p = convertCoord(anno.points[i]);
                ctx.lineTo(p.x, p.y);
            }
            ctx.closePath();
            ctx.stroke();
            ctx.globalAlpha = 0.2; ctx.fill(); ctx.globalAlpha = 1.0;
        }
        else if (anno.start && anno.end) { // Medida
            const p1 = convertCoord(anno.start);
            const p2 = convertCoord(anno.end);
            ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.stroke();
            
            const fontSize = 18 * drawingScaleFactor;
            ctx.font = \`bold \${fontSize}px Arial\`;
            ctx.fillStyle = color;
            ctx.textAlign = 'center'; ctx.textBaseline = 'bottom';
            const midX = (p1.x + p2.x) / 2;
            const midY = (p1.y + p2.y) / 2;
            
            ctx.shadowBlur = 0; ctx.lineWidth = 4; ctx.strokeStyle = 'black';
            ctx.strokeText(anno.text, midX, midY - 10);
            ctx.fillText(anno.text, midX, midY - 10);
        }
        else if (anno.type && anno.size) { // Seta
            const center = convertCoord({x: anno.x, y: anno.y});
            const size = (anno.size * img.naturalWidth);
            ctx.translate(center.x, center.y);
            ctx.rotate(anno.rotation);
            ctx.scale(anno.scale, anno.scale);
            ctx.beginPath();
            ctx.moveTo(-size/2, 0); ctx.lineTo(size/2, 0);
            ctx.lineTo(size/2 - size*0.3, -size*0.2);
            ctx.moveTo(size/2, 0);
            ctx.lineTo(size/2 - size*0.3, size*0.2);
            ctx.stroke();
        }
        else if (anno.text) { // Texto
             const p = convertCoord({x: anno.x, y: anno.y});
             const fontSize = (parseInt(anno.font)||20) * drawingScaleFactor;
             ctx.font = \`\${fontSize}px Arial\`;
             ctx.fillStyle = color;
             ctx.strokeStyle = 'black'; ctx.lineWidth = 3;
             ctx.strokeText(anno.text, p.x, p.y);
             ctx.fillText(anno.text, p.x, p.y);
        }
        else if (anno.points) { // Tra√ßo Livre
            ctx.beginPath();
            const start = convertCoord(anno.points[0]);
            ctx.moveTo(start.x, start.y);
            for(let i=1; i<anno.points.length; i++) {
                const p = convertCoord(anno.points[i]);
                ctx.lineTo(p.x, p.y);
            }
            ctx.stroke();
        }
        ctx.restore();
    }

    function convertCoord(p) {
        return { x: p.x * img.naturalWidth, y: p.y * img.naturalHeight };
    }

    function setupEvents() {
        // --- ZOOM E PAN (Mouse) ---
        viewer.addEventListener('mousedown', e => { isDragging = true; startX = e.clientX - panX; startY = e.clientY - panY; viewer.style.cursor = 'grabbing'; });
        window.addEventListener('mousemove', e => { // Window garante arrastar mesmo saindo do canvas
            if(isDragging) { 
                panX = e.clientX - startX; 
                panY = e.clientY - startY; 
                render(); 
            }
        });
        window.addEventListener('mouseup', () => { isDragging = false; viewer.style.cursor = 'default'; });
        
        viewer.addEventListener('wheel', e => {
            e.preventDefault();
            const zoomIntensity = 0.1;
            const delta = e.deltaY > 0 ? (1 - zoomIntensity) : (1 + zoomIntensity);
            
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            // Zoom no ponto do mouse
            const newScale = scale * delta;
            panX = mouseX - (mouseX - panX) * delta;
            panY = mouseY - (mouseY - panY) * delta;
            scale = newScale;
            render();
        });

        // --- LISTA LATERAL ---
        findingsList.addEventListener('mouseover', e => {
            const item = e.target.closest('p[data-annotation-id]');
            if(item) {
                hoveredAnnotationId = item.dataset.annotationId;
                render();
            }
        });

        findingsList.addEventListener('mouseout', e => {
            hoveredAnnotationId = null;
            render();
        });

        findingsList.addEventListener('click', e => {
            const item = e.target.closest('p[data-annotation-id]');
            
            // Remove destaque anterior
            document.querySelectorAll('.finding-item').forEach(el => el.classList.remove('active'));

            if(item) {
                const id = item.dataset.annotationId;

                // SE CLICAR NO J√Å ATIVO -> DESATIVA E RESETA
                if (activeAnnotationId === id) {
                    activeAnnotationId = null;
                    showAll = false;
                    fitImageToScreen(); // Volta ao normal
                } else {
                    // NOVO CLIQUE -> FOCA
                    activeAnnotationId = id;
                    showAll = false;
                    item.classList.add('active');
                    const anno = DATA.annotations.find(a => a.id === id);
                    if(anno) centerOnAnnotation(anno);
                }
            } else {
                // Clique no vazio
                activeAnnotationId = null;
                showAll = false;
                fitImageToScreen();
            }
            render();
        });

        document.getElementById('btn-toggle-all').addEventListener('click', () => {
            showAll = !showAll;
            activeAnnotationId = null;
            document.querySelectorAll('.finding-item').forEach(el => el.classList.remove('active'));
            fitImageToScreen();
        });
        
        document.getElementById('btn-reset-zoom').addEventListener('click', () => {
            activeAnnotationId = null;
            fitImageToScreen();
        });
        
        // --- TOQUE (CELULAR) ---
        let initialPinchDist = 0;
        let initialScale = 1;
        
        viewer.addEventListener('touchstart', e => {
            if (e.touches.length === 2) {
                initialPinchDist = Math.hypot(e.touches[0].pageX - e.touches[1].pageX, e.touches[0].pageY - e.touches[1].pageY);
                initialScale = scale;
            } else if (e.touches.length === 1) {
                isDragging = true;
                startX = e.touches[0].clientX - panX;
                startY = e.touches[0].clientY - panY;
            }
        }, {passive: false});

        viewer.addEventListener('touchmove', e => {
            e.preventDefault();
            if (e.touches.length === 2) {
                const dist = Math.hypot(e.touches[0].pageX - e.touches[1].pageX, e.touches[0].pageY - e.touches[1].pageY);
                const delta = dist / initialPinchDist;
                
                // Zoom simples no centro da tela (mais est√°vel para mobile)
                const centerX = viewer.offsetWidth / 2;
                const centerY = viewer.offsetHeight / 2;
                
                const newScale = initialScale * delta;
                panX = centerX - (centerX - panX) * (newScale / scale);
                panY = centerY - (centerY - panY) * (newScale / scale);
                scale = newScale;
                render();
            } else if (isDragging && e.touches.length === 1) {
                panX = e.touches[0].clientX - startX;
                panY = e.touches[0].clientY - startY;
                render();
            }
        }, {passive: false});
        
        viewer.addEventListener('touchend', () => isDragging = false);
    }
</script>
</body>
</html>
