<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Laudo Interativo</title>
    <style>
        :root { --bg-color: #121212; --panel-bg: #1e1e1e; --text-color: #e0e0e0; --accent: #3498db; --highlight: #f1c40f; }
        body { margin: 0; padding: 0; font-family: 'Segoe UI', Roboto, sans-serif; background-color: var(--bg-color); color: var(--text-color); height: 100vh; overflow: hidden; display: flex; flex-direction: row; }
        
        #viewer-area { flex: 1; position: relative; overflow: hidden; background-color: #000; touch-action: none; display: flex; align-items: center; justify-content: center; }
        canvas { display: block; width: 100%; height: 100%; }
        
        #sidebar { width: 350px; background-color: var(--panel-bg); border-left: 1px solid #333; display: flex; flex-direction: column; z-index: 100; box-shadow: -2px 0 10px rgba(0,0,0,0.5); }
        #header { padding: 15px; background: #252525; border-bottom: 1px solid #333; text-align: center; }
        #header h2 { margin: 0; color: var(--accent); font-size: 18px; }
        
        #findings-list { flex: 1; overflow-y: auto; padding: 15px; }
        .finding-item { background: #2a2a2a; margin-bottom: 10px; padding: 12px; border-radius: 6px; cursor: pointer; transition: 0.2s; border-left: 4px solid transparent; font-size: 14px; line-height: 1.4; color: #fff; }
        .finding-item:hover { background: #333; transform: translateX(5px); }
        .finding-item.active { background: #383838; border-color: var(--highlight); box-shadow: 0 0 15px rgba(255, 255, 255, 0.05); }
        
        #controls { padding: 15px; border-top: 1px solid #333; display: flex; gap: 10px; flex-direction: column; }
        .btn { background: var(--accent); color: white; border: none; padding: 12px; border-radius: 6px; font-weight: bold; cursor: pointer; font-size: 14px; width: 100%; transition: 0.2s; }
        .btn:hover { filter: brightness(1.1); }
        .btn.secondary { background: #444; }

        @media (max-width: 768px) {
            body { flex-direction: column; }
            #sidebar { width: 100%; height: 40%; border-left: none; border-top: 2px solid var(--accent); }
            #viewer-area { height: 60%; }
        }
    </style>
</head>
<body>

    <div id="viewer-area">
        <canvas id="canvas-report"></canvas>
    </div>

    <div id="sidebar">
        <div id="header">
            <h2>Achados Radiogr√°ficos</h2>
        </div>
        <div id="findings-list">
            <!-- O conte√∫do ser√° injetado via Javascript -->
            <p style="text-align:center; color: #777;">Carregando achados...</p>
        </div>
        <div id="controls">
            <button id="btn-toggle-all" class="btn">üëÅÔ∏è Ver Todos na Imagem</button>
            <button id="btn-reset-zoom" class="btn secondary">‚ü≤ Resetar Visualiza√ß√£o</button>
        </div>
    </div>

<script>
    // --- L√ìGICA DE INICIALIZA√á√ÉO E DECODIFICA√á√ÉO ---
    let DATA = null;

    try {
        // Pega o que est√° depois do # na URL
        const hash = window.location.hash.substring(1);
        if (hash) {
            // Decodifica Base64 -> String JSON -> Objeto
            const jsonString = decodeURIComponent(escape(atob(hash)));
            DATA = JSON.parse(jsonString);
            
            // Injeta o HTML dos achados na Sidebar
            document.getElementById('findings-list').innerHTML = DATA.findingsHtml;
        } else {
            document.getElementById('findings-list').innerHTML = "<p style='text-align:center; color:red;'>Erro: Nenhum dado encontrado no link.</p>";
        }
    } catch (e) {
        console.error(e);
        document.getElementById('findings-list').innerHTML = "<p style='text-align:center; color:red;'>Erro ao processar o laudo. O link pode estar corrompido.</p>";
    }

    if (DATA) {
        const viewer = document.getElementById('viewer-area');
        const canvas = document.getElementById('canvas-report');
        const ctx = canvas.getContext('2d');
        const findingsList = document.getElementById('findings-list');
        
        let img = new Image();
        let scale = 1, panX = 0, panY = 0;
        let isDragging = false, startX, startY;
        
        let showAll = false;
        let activeAnnotationId = null;
        let hoveredAnnotationId = null;
        
        let drawingScaleFactor = 1;

        img.onload = () => {
            resizeCanvas();
            // Fator de escala para linhas n√£o ficarem finas em alta resolu√ß√£o
            drawingScaleFactor = Math.max(img.naturalWidth / 1500, 1);
            
            fitImageToScreen(); 
            setupEvents();
            
            // Adiciona classe de estilo aos itens injetados
            document.querySelectorAll('#findings-list p').forEach(p => p.classList.add('finding-item'));
        };
        img.src = DATA.image;

        window.addEventListener('resize', () => { resizeCanvas(); fitImageToScreen(); });

        function resizeCanvas() {
            canvas.width = viewer.offsetWidth;
            canvas.height = viewer.offsetHeight;
            render();
        }

        function render() {
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.setTransform(scale, 0, 0, scale, panX, panY);
            ctx.drawImage(img, 0, 0);

            if (showAll) {
                DATA.annotations.forEach(anno => drawAnnotation(anno, false));
            } else {
                const targetId = hoveredAnnotationId || activeAnnotationId;
                if (targetId) {
                    const anno = DATA.annotations.find(a => a.id === targetId);
                    if (anno) drawAnnotation(anno, true);
                }
            }
        }

        // --- ZOOM INTELIGENTE (Bounding Box) ---
        function centerOnAnnotation(anno) {
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;

            const addPoint = (relX, relY) => {
                minX = Math.min(minX, relX); maxX = Math.max(maxX, relX);
                minY = Math.min(minY, relY); maxY = Math.max(maxY, relY);
            };

            if (anno.points) { 
                anno.points.forEach(p => addPoint(p.x, p.y));
            } else if (anno.start && anno.end) { 
                addPoint(anno.start.x, anno.start.y);
                addPoint(anno.end.x, anno.end.y);
            } else { 
                const px = (anno.x !== undefined) ? anno.x : 0.5;
                const py = (anno.y !== undefined) ? anno.y : 0.5;
                const margin = 0.05; 
                addPoint(px - margin, py - margin);
                addPoint(px + margin, py + margin);
            }

            const imgW = img.naturalWidth;
            const imgH = img.naturalHeight;
            
            const annoWidth = (maxX - minX) * imgW;
            const annoHeight = (maxY - minY) * imgH;
            
            const centerX = ((minX + maxX) / 2) * imgW;
            const centerY = ((minY + maxY) / 2) * imgH;

            const paddingFactor = 0.6; // Ocupa 60% da tela
            const scaleX = canvas.width / annoWidth;
            const scaleY = canvas.height / annoHeight;
            
            let targetScale = Math.min(scaleX, scaleY) * paddingFactor;

            // Limites de seguran√ßa do zoom
            const minScaleAllowed = Math.min(canvas.width / imgW, canvas.height / imgH);
            const maxScaleAllowed = 5.0; 
            
            targetScale = Math.max(targetScale, minScaleAllowed);
            targetScale = Math.min(targetScale, maxScaleAllowed);

            scale = targetScale;
            panX = (canvas.width / 2) - (centerX * scale);
            panY = (canvas.height / 2) - (centerY * scale);
            
            render();
        }

        function fitImageToScreen() {
            const scaleX = canvas.width / img.naturalWidth;
            const scaleY = canvas.height / img.naturalHeight;
            scale = Math.min(scaleX, scaleY); 
            panX = (canvas.width - (img.naturalWidth * scale)) / 2;
            panY = (canvas.height - (img.naturalHeight * scale)) / 2;
            render();
        }

        function drawAnnotation(anno, isActive) {
            const findingEl = document.querySelector(`p[data-annotation-id="${anno.id}"]`);
            const color = findingEl ? findingEl.dataset.highlightColor : '#00FFFF';

            ctx.save();
            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            
            const baseWidth = (anno.thickness || 3) * drawingScaleFactor;
            ctx.lineWidth = isActive ? baseWidth * 1.5 : baseWidth;
            ctx.lineJoin = 'round'; ctx.lineCap = 'round';
            ctx.shadowColor = 'black'; ctx.shadowBlur = 5 * drawingScaleFactor;

            if (anno.points && anno.fillColor) { 
                ctx.beginPath();
                const s = convertCoord(anno.points[0]); ctx.moveTo(s.x, s.y);
                for(let i=1; i<anno.points.length; i++) { const p = convertCoord(anno.points[i]); ctx.lineTo(p.x, p.y); }
                ctx.closePath(); ctx.stroke();
                ctx.globalAlpha = 0.2; ctx.fill(); ctx.globalAlpha = 1.0;
            }
            else if (anno.start && anno.end) { 
                const p1 = convertCoord(anno.start), p2 = convertCoord(anno.end);
                ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.stroke();
                const fontSize = 18 * drawingScaleFactor;
                ctx.font = `bold ${fontSize}px Arial`; ctx.fillStyle = color; ctx.textAlign = 'center'; ctx.textBaseline = 'bottom';
                const mx = (p1.x + p2.x)/2, my = (p1.y + p2.y)/2;
                ctx.shadowBlur = 0; ctx.lineWidth = 4; ctx.strokeStyle = 'black';
                ctx.strokeText(anno.text, mx, my - 10); ctx.fillText(anno.text, mx, my - 10);
            }
            else if (anno.type && anno.size) { 
                const c = convertCoord({x: anno.x, y: anno.y});
                const sz = (anno.size * img.naturalWidth);
                ctx.translate(c.x, c.y); ctx.rotate(anno.rotation); ctx.scale(anno.scale, anno.scale);
                ctx.beginPath(); ctx.moveTo(-sz/2, 0); ctx.lineTo(sz/2, 0);
                ctx.lineTo(sz/2 - sz*0.3, -sz*0.2); ctx.moveTo(sz/2, 0); ctx.lineTo(sz/2 - sz*0.3, sz*0.2);
                ctx.stroke();
            }
            else if (anno.text) { 
                 const p = convertCoord({x: anno.x, y: anno.y});
                 const fs = (parseInt(anno.font)||20) * drawingScaleFactor;
                 ctx.font = `${fs}px Arial`; ctx.fillStyle = color; ctx.strokeStyle = 'black'; ctx.lineWidth = 3;
                 ctx.strokeText(anno.text, p.x, p.y); ctx.fillText(anno.text, p.x, p.y);
            }
            else if (anno.points) { 
                ctx.beginPath(); const s = convertCoord(anno.points[0]); ctx.moveTo(s.x, s.y);
                for(let i=1; i<anno.points.length; i++) { const p = convertCoord(anno.points[i]); ctx.lineTo(p.x, p.y); }
                ctx.stroke();
            }
            ctx.restore();
        }

        function convertCoord(p) { return { x: p.x * img.naturalWidth, y: p.y * img.naturalHeight }; }

        function setupEvents() {
            // MOUSE
            viewer.addEventListener('mousedown', e => { isDragging = true; startX = e.clientX - panX; startY = e.clientY - panY; viewer.style.cursor = 'grabbing'; });
            window.addEventListener('mousemove', e => { 
                if(isDragging) { panX = e.clientX - startX; panY = e.clientY - startY; render(); }
            });
            window.addEventListener('mouseup', () => { isDragging = false; viewer.style.cursor = 'default'; });
            
            viewer.addEventListener('wheel', e => {
                e.preventDefault();
                const d = e.deltaY > 0 ? 0.9 : 1.1;
                const rect = canvas.getBoundingClientRect();
                const mx = e.clientX - rect.left;
                const my = e.clientY - rect.top;
                const ns = scale * d;
                panX = mx - (mx - panX) * d;
                panY = my - (my - panY) * d;
                scale = ns;
                render();
            });

            // SIDEBAR
            findingsList.addEventListener('mouseover', e => {
                const item = e.target.closest('p[data-annotation-id]');
                if(item) { hoveredAnnotationId = item.dataset.annotationId; render(); }
            });
            findingsList.addEventListener('mouseout', e => { hoveredAnnotationId = null; render(); });

            findingsList.addEventListener('click', e => {
                const item = e.target.closest('p[data-annotation-id]');
                document.querySelectorAll('.finding-item').forEach(el => el.classList.remove('active'));

                if(item) {
                    const id = item.dataset.annotationId;
                    if (activeAnnotationId === id) { 
                        activeAnnotationId = null;
                        showAll = false;
                        fitImageToScreen();
                    } else { 
                        activeAnnotationId = id;
                        showAll = false;
                        item.classList.add('active');
                        const anno = DATA.annotations.find(a => a.id === id);
                        if(anno) centerOnAnnotation(anno); 
                    }
                } else {
                    activeAnnotationId = null;
                    showAll = false;
                    fitImageToScreen();
                }
                render();
            });

            document.getElementById('btn-toggle-all').addEventListener('click', () => {
                showAll = !showAll;
                activeAnnotationId = null;
                document.querySelectorAll('.finding-item').forEach(el => el.classList.remove('active'));
                fitImageToScreen();
                render();
            });
            document.getElementById('btn-reset-zoom').addEventListener('click', () => {
                activeAnnotationId = null;
                fitImageToScreen();
            });
            
            // TOUCH
            let initDist = 0, initScale = 1;
            viewer.addEventListener('touchstart', e => {
                if (e.touches.length === 2) {
                    initDist = Math.hypot(e.touches[0].pageX - e.touches[1].pageX, e.touches[0].pageY - e.touches[1].pageY);
                    initScale = scale;
                } else if (e.touches.length === 1) {
                    isDragging = true; startX = e.touches[0].clientX - panX; startY = e.touches[0].clientY - panY;
                }
            }, {passive: false});

            viewer.addEventListener('touchmove', e => {
                e.preventDefault();
                if (e.touches.length === 2) {
                    const dist = Math.hypot(e.touches[0].pageX - e.touches[1].pageX, e.touches[0].pageY - e.touches[1].pageY);
                    const delta = dist / initDist;
                    const cx = viewer.offsetWidth / 2;
                    const cy = viewer.offsetHeight / 2;
                    const ns = initScale * delta;
                    panX = cx - (cx - panX) * (ns / scale);
                    panY = cy - (cy - panY) * (ns / scale);
                    scale = ns;
                    render();
                } else if (isDragging && e.touches.length === 1) {
                    panX = e.touches[0].clientX - startX; panY = e.touches[0].clientY - startY; render();
                }
            }, {passive: false});
            viewer.addEventListener('touchend', () => isDragging = false);
        }
    }
</script>
</body>
</html>
